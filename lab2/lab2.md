### 练习

对实验报告的要求：

- 基于markdown格式来完成，以文本方式为主
- 填写各个基本练习中要求完成的报告内容
- 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
- 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
- 列出你认为OS原理中很重要，但在实验中没有对应上的知识点




#### 练习0：填写已有实验

本实验依赖实验1。请把你做的实验1的代码填入本实验中代码中有“LAB1”的注释相应部分并按照实验手册进行进一步的修改。具体来说，就是跟着实验手册的教程一步步做，然后完成教程后继续完成完成exercise部分的剩余练习。

#### 练习1：理解first-fit 连续物理内存分配算法（思考题）

first-fit 连续物理内存分配算法作为物理内存分配一个很基础的方法，需要同学们理解它的实现过程。请大家仔细阅读实验手册的教程并结合 `kern/mm/default_pmm.c`中的相关代码，认真分析default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数，并描述程序在进行物理内存分配的过程以及各个函数的作用。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：

- 你的first fit算法是否有进一步的改进空间？

`default_init`:初始化空闲块列表 `free_list`，将可用的物理页面数设为0

`default_init_memmap`:初始化从base开始的n个空闲页面，将空闲页面加到free_list中

* `base`指向要初始化的页面的指针，`n`是要初始化的数量，遍历从 `base`开始的 `n`个页面，设置初始化状态。
* 遍历free_list，如果 `base` 页面地址小于当前页面 `page` 的地址，说明应该将 `base` 页面插入到当前页面之前。如果当前页面是空闲列表中的最后一个页面，在空闲列表的末尾添加 `base` 页面。


`default_alloc_pages`:从空闲页面列表中分配 `n` 个页面。从列表头部遍历空闲页面列表，若找到第一个property大于n的空闲页面，则分割该页面，将剩余部分重新加入到空闲列表中。

* 检查当前可用的空闲页面数量 `nr_free` 是否足够。如果可用页面少于 `n`，则返回 `NULL`，表示无法满足请求。
* 定义一个指针 `page`，用于存储找到的足够大的空闲页面。定义一个指针 `le`，初始化为空闲页面列表的头部。遍历链表，当前页面 `p` 的 `property` 是否大于或等于 `n`。如果满足条件，说明找到了足够大的空闲页面，将其指针赋值给 `page` 并退出循环。

* 获取当前页面 `page` 在空闲列表中的前一个节点 `prev`。从空闲列表中删除当前页面 `page`。
* 检查 `page` 的 `property` 是否大于 `n`，即是否可以分割页面。定义一个新的页面指针 `p`，指向分配后剩余的页面，再将剩余页面 `p` 添加回空闲列表，保持列表的结构。

`default_free_pages`:将释放的内存块按照顺序插入free_list中，并与相邻的页面进行合并以减少碎片化。

* 若空闲链表 `free_list` 为空，直接将当前页面链入空闲链表；若不为空，遍历空闲链表，找找到第一个页面 `page`，其地址大于 `base`，将 `base` 插入在 `page` 之前。如果到达链表末尾，则将 `base` 插入到最后。

插入后尝试与前一个页面合并：

* 找到 `base` 前面的页面 `p`，如果 `p` 的结尾刚好和 `base` 相接（即 `p + p->property == base`），则将 `p` 和 `base` 合并，更新 `p->property`。
* 清除 `base` 的属性，并从空闲链表中删除 `base`，将 `base` 更新为合并后的起始页面 `p`。

尝试与后一个页面合并：

*  找到 `base` 后面的页面 `p`，如果 `base` 的结尾刚好和 `p` 相接（即 `base + base->property == p`），则将 `base` 和 `p` 合并，更新 `base->property`。

* 清除 `p` 的属性，并将 `p` 从空闲链表中删除。

#### 改进空间

1、开销太大：

从低地址开始搜索的时间复杂度为O(n),可以考虑使用AVL树等数据结构维护空闲块，其中按照中序遍历得到的空闲块序列的物理地址恰好按照从小到大排序，使用二分查找查找到物理地址最小的能够满足条件的空闲地址块。

2、延迟合并：

针对产生碎片的情况，设置一定的延迟合并策略，即积累到一定数量的小块页面后，再统一合并，减少合并操作的频率。

3、内存碎片：

长期运行中，可能会出现大量小的空闲页面块，导致无法为大块内存请求提供足够的连续空间。

可以将空闲页面分成多个大小类，使用不同的链表或其他数据结构分别管理各类页面。当需要分配内存时，首先从对应大小的页面链表中查找，减少遍历其他不匹配大小的页面的时间。

#### 练习2：实现 Best-Fit 连续物理内存分配算法（需要编程）

在完成练习一后，参考kern/mm/default_pmm.c对First Fit算法的实现，编程实现Best Fit页面分配算法，算法的时空复杂度不做要求，能通过测试即可。
请在实验报告中简要说明你的设计实现过程，阐述代码是如何对物理内存进行分配和释放，并回答如下问题：

- 你的 Best-Fit 算法是否有进一步的改进空间？

#### 核心代码实现

思路：找到大于等于n的最小空闲块

```
size_t min_size = nr_free + 1;
while ((le = list_next(le)) != &free_list) {
      struct Page *p = le2page(le, page_link);
      if (p->property >= n && p->property<min_size) {
          page = p;
          min_size = p->property;

    }
  }
```

  其他代码部分与first fit相同。

如何对物理内存进行分配和释放：

首先初始化物理内存管理器，设置 free_list 和 nr_free，在系统启动时，通过调用 best_fit_init_memmap 函数初始化可用的物理页面；在进程或内核代码中，使用 best_fit_alloc_pages 函数来分配物理页面，并使用 best_fit_free_pages 函数来释放页面。

分配：遍历 free_list 列表，查找满足需求的空闲页框。如果找到满足需求的页面，记录该页面以及当前找到的最小连续空闲页框数量。最终获得满足需求且连续空闲页数量最少的块，分配其中的页面，并将剩余的页面添加回 free_list 列表。如果没有找到满足条件的块，返回NULL

释放：将这些页面添加回 free_list 列表，并尝试合并相邻的空闲块，以最大程度地减少碎片化；更新 nr_free 变量以反映可用页面的数量。



#### 改进空间

1、开销太大：

best fit 比 first fit 开销更大，也可以考虑使用AVL树或跳表等数据结构维护空闲块，使查找效率从 O(n) 降低到 O(log n)。

2、不能很好适应内存多样化请求：

Best Fit 的适应性对于请求大小不均匀的场景表现较好，但在长期运行后，特别是大块和小块内存请求频繁交替出现时，Best Fit 可能会使得部分大块空闲空间无法有效利用。

结合分区分配策略，针对不同大小的内存请求使用不同的空闲块管理策略。例如，大块内存分配使用 First Fit，小块内存分配使用 Best Fit。这样可以在不同的场景下发挥各自优势。

3、内存碎片：

长期运行中，可能会出现大量更小的内存碎片，导致大量内存虽然空闲，但无法满足任何实用的内存请求，从而降低内存的整体利用率。

可以考虑使用buddy system






#### 扩展练习Challenge：buddy system（伙伴系统）分配算法（需要编程）

Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128...

- 参考[伙伴分配器的一个极简实现](http://coolshell.cn/articles/10427.html)， 在ucore中实现buddy system分配算法，要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

#### 扩展练习Challenge：任意大小的内存单元slub分配算法（需要编程）

slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。

- 参考[linux的slub分配算法/](http://www.ibm.com/developerworks/cn/linux/l-cn-slub/)，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

#### 扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）

- 如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？

> Challenges是选做，完成Challenge的同学可单独提交Challenge。完成得好的同学可获得最终考试成绩的加分。

我们查阅资料，得到以下方法：

**1、发出中断调用** ：通过  **BIOS 中断 0x15, 功能号 E820h** ，并在寄存器中设置适当的参数，BIOS 返回一个包含系统中各内存段的类型及大小的内存映射表。

**2、****解析内存映射表** ：BIOS 返回的内存映射表列出了系统中所有的物理内存区域，包括可用的 RAM、保留的硬件设备地址空间等。操作系统根据这些信息划分出可以使用的物理内存。

**3、** **初始化物理内存管理器** ：ucore 使用这些信息初始化物理内存管理器，并将可用的物理内存区域加入内存分配器中，以便后续的页表管理和虚拟内存管理。

一个可能的代码：

```
struct e820map {
    uint32_t nr_map;  // 可用区域数量
    struct {
        uint64_t addr;  // 起始地址
        uint64_t size;  // 区域大小
        uint32_t type;  // 区域类型（1 表示可用内存）
    } map[E820MAX];
};

void get_memory_map() {
    struct e820map *memmap = (struct e820map*)0x8000;  // 内存映射表存放地址
    int success = 0;
    asm volatile (
        "int $0x15"  // 调用 BIOS 中断
        : "=a" (success)
        : "a" (0xE820), "b" (0), "c" (24), "d" (0x534D4150), "D" (memmap)
        : "memory"
    );
    if (success == 1) {
        // 成功获取到内存映射表，接下来可以使用 memmap 进行物理内存管理初始化
    }
}

```
